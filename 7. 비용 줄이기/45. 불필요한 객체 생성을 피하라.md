객체 생성은 언제나 비용이 들어가며, 상황에 따라서는 굉장히 큰 비용이 들어갈 수 있음.  
따라서 불필요한 객체 생성을 피하는 것이 최적화의 관점에서 좋다.
***
### 1. 객체 선언
하나의 인스턴스를 재사용해도 된다면 `object`로 객체를 선언하자.

### 2. 캐시를 활용하는 팩토리 함수
만들어진 인스턴스를 캐싱하여 사용하기.  
단점으로는 캐시를 위한 추가적인 메모리를 사용해야 하므로 메모리 부족 문제가 발생할 수 있다.  
메모리가 부족할 때 추가로 값을 정리하는 SoftReference를 사용할 수도 있다.

### 3. 무거운 객체를 외부 스코프로 보내기
연산을 외부로 추출해서 값 계산을 추가로 하지 않게 만든다.
```kotlin
// 요소 개수만큼 this.max()가 호출되고 있음
fun <T: Comparable<T>> Iterable<T>.countMax(): Int =
    count { it == this.max() }

// max 값을 저장할 때 this.max()를 한번만 호출하도록 변경
fun <T: Comparable<T>> Iterable<T>.countMax(): Int {
    val max = this.max()
    return count { it == max }
}
```

### 4. 지연 초기화
실제로 인스턴스를 사용해야 하는 순간에 인스턴스를 생성하도록 하여 초기화를 지연시킨다.  
단점은 응답 시간이 중요한 동작이 수행될 때 미리 초기화 하지 못하고 지연 초기화 해버리면 처음 동작할 때 속도가 느릴수도 있다. 

### 5. 기본 자료형 사용하기
다음과 같은 상황에서 컴파일러는 기본 자료형을 사용하지 않고 기본 자료형을 랩(Wrap)한 자료형을 사용한다.
1. nullable 타입을 사용할 때
2. 타입을 제네릭으로 사용할 때

가독성을 해치지 않는 선에서 성능이 중요한 경우 최대한 기본 자료형을 사용하도록 한다. 
```kotlin
// nullable한 변수를 결과로 리턴하는게 아닌
// 중간에 명시적으로 null을 리턴하는 조건을 건다.
fun Iterator<Int>.maxOrNull(): Int? {
    // var max: Int? = null    -> X
    var max: Int = 0

    // 생략..

    if (/* 조건 */) return null

    // 생략..

    return max
}
```
